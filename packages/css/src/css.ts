import type { CSSInterpolation } from "@emotion/serialize";
import { serializeStyles } from "@emotion/serialize";
import { getGtkCache } from "./cache.js";

/**
 * Branded type for CSS class names generated by {@link css}.
 */
type CSSClassName = string & { __brand: "css" };

function expandNestedRules(styles: string, className: string): string {
    const selector = `.${className}`;
    const expandedStyles = styles.replace(/&/g, selector);

    const rules: string[] = [];
    let topLevelProperties = "";
    let currentSegment = "";
    let braceDepth = 0;

    for (let i = 0; i < expandedStyles.length; i++) {
        const char = expandedStyles[i];

        if (char === "{") {
            currentSegment += char;
            braceDepth++;
        } else if (char === "}") {
            braceDepth--;
            currentSegment += char;
            if (braceDepth === 0) {
                rules.push(currentSegment.trim());
                currentSegment = "";
            }
        } else if (char === ";" && braceDepth === 0) {
            topLevelProperties += currentSegment + char;
            currentSegment = "";
        } else {
            currentSegment += char;
        }
    }

    if (currentSegment.trim() && braceDepth === 0) {
        topLevelProperties += currentSegment;
    }

    const allRules: string[] = [];
    if (topLevelProperties.trim()) {
        allRules.push(`${selector}{${topLevelProperties.trim()}}`);
    }
    allRules.push(...rules);

    return allRules.join("\n");
}

/**
 * Creates a CSS class from style definitions.
 *
 * Uses Emotion's CSS-in-JS system adapted for GTK CSS. Supports nested selectors
 * using `&` for the parent selector reference.
 *
 * @param args - CSS style definitions (objects, template literals, or interpolations)
 * @returns A unique class name to use with `cssClasses` prop
 *
 * @example
 * ```tsx
 * import { css } from "@gtkx/css";
 *
 * const buttonStyle = css({
 *   padding: "8px 16px",
 *   borderRadius: "4px",
 *   "&:hover": {
 *     backgroundColor: "@accent_bg_color",
 *   },
 * });
 *
 * <GtkButton cssClasses={[buttonStyle]} label="Styled Button" />
 * ```
 *
 * @example
 * ```tsx
 * // Template literal syntax
 * const labelStyle = css`
 *   font-size: 14px;
 *   color: @theme_text_color;
 * `;
 * ```
 *
 * @see {@link cx} for combining class names
 * @see {@link injectGlobal} for global styles
 */
export const css = (...args: CSSInterpolation[]): CSSClassName => {
    const cache = getGtkCache();
    const serialized = serializeStyles(args, cache.registered);

    const className = `${cache.key}-${serialized.name}`;

    if (cache.inserted[serialized.name] === undefined) {
        const cssRule = expandNestedRules(serialized.styles, className);
        cache.sheet.insert(cssRule);
        cache.inserted[serialized.name] = serialized.styles;
        cache.registered[className] = serialized.styles;
    }

    return className as CSSClassName;
};

/**
 * Combines multiple class names into an array for use with cssClasses prop.
 *
 * Filters out falsy values, allowing conditional class application.
 *
 * @param classNames - Class names, booleans, undefined, or null values
 * @returns Array of valid class names
 *
 * @example
 * ```tsx
 * import { css, cx } from "@gtkx/css";
 *
 * const base = css({ padding: "8px" });
 * const active = css({ backgroundColor: "@accent_bg_color" });
 *
 * <GtkButton
 *   cssClasses={cx(base, isActive && active, "custom-class")}
 *   label="Button"
 * />
 * ```
 */
export const cx = (...classNames: (string | boolean | undefined | null)[]): string[] =>
    classNames.filter((cn): cn is string => typeof cn === "string" && cn.length > 0);

/**
 * Injects global CSS styles without a wrapping class.
 *
 * Use for application-wide styles, CSS variables, or styling native GTK widgets.
 *
 * @param args - CSS style definitions
 *
 * @example
 * ```tsx
 * import { injectGlobal } from "@gtkx/css";
 *
 * injectGlobal`
 *   window {
 *     background-color: @theme_bg_color;
 *   }
 *
 *   .title-1 {
 *     font-size: 24px;
 *     font-weight: bold;
 *   }
 * `;
 * ```
 *
 * @see {@link css} for scoped class-based styles
 */
export const injectGlobal = (...args: CSSInterpolation[]): void => {
    const cache = getGtkCache();
    const serialized = serializeStyles(args, cache.registered);

    if (cache.inserted[`global-${serialized.name}`] === undefined) {
        cache.sheet.insert(serialized.styles);
        cache.inserted[`global-${serialized.name}`] = serialized.styles;
    }
};

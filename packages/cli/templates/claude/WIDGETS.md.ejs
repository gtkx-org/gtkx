# GTKX Widget Reference

## Common Props (All Widgets)

| Prop | Type | Description |
|------|------|-------------|
| `hexpand` / `vexpand` | boolean | Expand to fill available space |
| `halign` / `valign` | `Gtk.Align.START \| CENTER \| END \| FILL` | Alignment |
| `marginStart/End/Top/Bottom` | number | Margins in pixels |
| `sensitive` | boolean | Enabled/disabled state |
| `visible` | boolean | Visibility |
| `cssClasses` | string[] | CSS classes for styling |
| `widthRequest` / `heightRequest` | number | Minimum size |

---

## Containers

### GtkBox
Linear layout (horizontal or vertical).

```tsx
<GtkBox orientation={Gtk.Orientation.VERTICAL} spacing={12}>
    {children}
</GtkBox>
```

### GtkGrid
2D grid with explicit positioning using `GridChild`.

```tsx
<GtkGrid rowSpacing={8} columnSpacing={12}>
    <x.GridChild column={0} row={0}><GtkLabel label="Name:" /></x.GridChild>
    <x.GridChild column={1} row={0}><GtkEntry hexpand /></x.GridChild>
    <x.GridChild column={0} row={1} columnSpan={2}><GtkButton label="Submit" /></x.GridChild>
</GtkGrid>
```

**GridChild props:** `column`, `row`, `columnSpan`, `rowSpan`

### GtkStack
Page container, shows one child at a time.

```tsx
<GtkStack page="page1" transitionType={Gtk.StackTransitionType.SLIDE_LEFT_RIGHT}>
    <x.StackPage id="page1" title="First" iconName="document-new">
        <Content1 />
    </x.StackPage>
    <x.StackPage id="page2" title="Second">
        <Content2 />
    </x.StackPage>
</GtkStack>
```

**StackPage props:** `id` (optional), `title`, `iconName`, `needsAttention`, `badgeNumber` (AdwViewStack only)

### GtkNotebook
Tabbed container with visible tabs.

```tsx
<GtkNotebook>
    <x.NotebookPage label="Tab 1"><Content1 /></x.NotebookPage>
    <x.NotebookPage label="Tab 2"><Content2 /></x.NotebookPage>
</GtkNotebook>
```

Custom tab widget:
```tsx
<x.NotebookPage>
    <x.NotebookPageTab>
        <GtkBox spacing={4}>
            <GtkImage iconName="folder-symbolic" />
            <GtkLabel label="Files" />
        </GtkBox>
    </x.NotebookPageTab>
    <Content />
</x.NotebookPage>
```

**NotebookPage props:** `label`, `tabExpand`, `tabFill`

### GtkPaned
Resizable split with draggable divider. **Requires Slot components.**

```tsx
<GtkPaned position={280} shrinkStartChild={false}>
    <x.Slot for={GtkPaned} id="startChild"><Sidebar /></x.Slot>
    <x.Slot for={GtkPaned} id="endChild"><MainContent /></x.Slot>
</GtkPaned>
```

### GtkOverlay
Stack widgets on top of each other. First child is base layer, additional children need `OverlayChild` wrapper.

```tsx
<GtkOverlay>
    <GtkButton label="Notifications" />
    <x.OverlayChild>
        <GtkLabel label="3" cssClasses={["badge"]} halign={Gtk.Align.END} valign={Gtk.Align.START} />
    </x.OverlayChild>
</GtkOverlay>
```

### GtkFixed
Absolute positioning. Use `x.FixedChild` wrapper for children.

```tsx
<GtkFixed>
    <x.FixedChild x={20} y={30}>
        <GtkLabel label="Top Left" />
    </x.FixedChild>
    <x.FixedChild x={200} y={100}>
        <GtkLabel label="Middle" />
    </x.FixedChild>
</GtkFixed>
```

**FixedChild props:** `x`, `y` (pixel coordinates)

### GtkScrolledWindow
Scrollable container.

```tsx
<GtkScrolledWindow vexpand hscrollbarPolicy={Gtk.PolicyType.NEVER}>
    <Content />
</GtkScrolledWindow>
```

---

## Virtual Lists

All virtual list widgets use `ListItem` children and a `renderItem` function.

### ListView
High-performance scrollable list with selection.

```tsx
<x.ListView<Item>
    estimatedItemHeight={48}
    vexpand
    selected={selectedId ? [selectedId] : []}
    selectionMode={Gtk.SelectionMode.SINGLE}
    onSelectionChanged={(ids) => setSelectedId(ids[0])}
    renderItem={(item) => <GtkLabel label={item?.name ?? ""} />}
>
    {items.map(item => <x.ListItem key={item.id} id={item.id} value={item} />)}
</x.ListView>
```

### GridView
Grid-based virtual scrolling.

```tsx
<x.GridView<Item>
    estimatedItemHeight={100}
    minColumns={2}
    maxColumns={4}
    renderItem={(item) => (
        <GtkBox orientation={Gtk.Orientation.VERTICAL}>
            <GtkImage iconName={item?.icon ?? "image-missing"} />
            <GtkLabel label={item?.name ?? ""} />
        </GtkBox>
    )}
>
    {items.map(item => <x.ListItem key={item.id} id={item.id} value={item} />)}
</x.GridView>
```

### GtkColumnView
Table with sortable columns.

```tsx
<GtkColumnView estimatedRowHeight={48} sortColumn="name" sortOrder={Gtk.SortType.ASCENDING} onSortChanged={handleSort}>
    <x.ColumnViewColumn<Item>
        title="Name"
        id="name"
        expand
        resizable
        sortable
        renderCell={(item) => <GtkLabel label={item?.name ?? ""} />}
    />
    <x.ColumnViewColumn<Item>
        title="Size"
        id="size"
        fixedWidth={100}
        renderCell={(item) => <GtkLabel label={item?.size ?? ""} />}
    />
    {items.map(item => <x.ListItem key={item.id} id={item.id} value={item} />)}
</GtkColumnView>
```

### GtkDropDown
Selection dropdown.

```tsx
<GtkDropDown selectedId={selectedId} onSelectionChanged={setSelectedId}>
    {options.map(opt => <x.SimpleListItem key={opt.id} id={opt.id} value={opt.label} />)}
</GtkDropDown>
```

### TreeListView
Hierarchical tree with expand/collapse.

```tsx
<x.TreeListView<FileNode>
    estimatedItemHeight={48}
    vexpand
    autoexpand={false}
    selectionMode={Gtk.SelectionMode.SINGLE}
    selected={selectedId ? [selectedId] : []}
    onSelectionChanged={(ids) => setSelectedId(ids[0])}
    renderItem={(item, row) => (
        <GtkBox spacing={8}>
            <GtkImage iconName={item?.isDirectory ? "folder-symbolic" : "text-x-generic-symbolic"} />
            <GtkLabel label={item?.name ?? ""} />
        </GtkBox>
    )}
>
    {files.map(file => (
        <x.TreeListItem key={file.id} id={file.id} value={file}>
            {file.children?.map(child => (
                <x.TreeListItem key={child.id} id={child.id} value={child} />
            ))}
        </x.TreeListItem>
    ))}
</x.TreeListView>
```

**TreeListItem props:** `id`, `value`, `indentForDepth`, `indentForIcon`, `hideExpander`, nested `children`

---

## Inputs

### GtkEntry
Single-line text input. **Requires two-way binding.**

```tsx
const [text, setText] = useState("");
<GtkEntry text={text} onChanged={(e) => setText(e.getText())} placeholderText="Enter text..." />
```

### GtkToggleButton
Toggle button. Auto-prevents signal feedback loops.

```tsx
<GtkToggleButton active={isActive} onToggled={() => setIsActive(!isActive)} label="Toggle" />
```

### GtkCheckButton
Checkbox.

```tsx
<GtkCheckButton active={checked} onToggled={() => setChecked(!checked)} label="Option" />
```

### GtkSwitch
On/off switch.

```tsx
<GtkSwitch active={enabled} onStateSet={() => { setEnabled(!enabled); return true; }} />
```

### GtkSpinButton
Numeric input with increment/decrement.

```tsx
<GtkSpinButton value={count} onValueChanged={(sb) => setCount(sb.getValue())} />
```

### GtkScale
Slider with optional marks.

```tsx
<GtkScale
    drawValue
    valuePos={Gtk.PositionType.TOP}
>
    <x.ScaleMark value={0} label="Min" />
    <x.ScaleMark value={50} />
    <x.ScaleMark value={100} label="Max" />
</GtkScale>
```

**ScaleMark props:** `value` (required), `position`, `label`

### GtkCalendar
Date picker with markable days.

```tsx
<GtkCalendar onDaySelected={(cal) => setDate(cal.getDate())}>
    <x.CalendarMark day={15} />
    <x.CalendarMark day={20} />
</GtkCalendar>
```

### GtkLevelBar
Progress/level indicator with customizable thresholds.

```tsx
<GtkLevelBar value={0.6}>
    <x.LevelBarOffset id="low" value={0.25} />
    <x.LevelBarOffset id="high" value={0.75} />
    <x.LevelBarOffset id="full" value={1.0} />
</GtkLevelBar>
```

---

## Display

### GtkLabel
```tsx
<GtkLabel label="Text" halign={Gtk.Align.START} wrap useMarkup />
```

### GtkButton
```tsx
<GtkButton label="Click" onClicked={handleClick} iconName="document-new-symbolic" />
```

### GtkImage
```tsx
<GtkImage iconName="folder-symbolic" pixelSize={48} />
```

---

## Header & Action Bars

### GtkHeaderBar
Title bar with packed widgets. Use `Pack.Start`, `Pack.End`, and `Slot` for titleWidget.

```tsx
<GtkHeaderBar>
    <x.PackStart><GtkButton iconName="go-previous-symbolic" /></x.PackStart>
    <x.Slot for={GtkHeaderBar} id="titleWidget">
        <GtkLabel label="Title" cssClasses={["title"]} />
    </x.Slot>
    <x.PackEnd><GtkMenuButton iconName="open-menu-symbolic" /></x.PackEnd>
</GtkHeaderBar>
```

### GtkActionBar
Bottom action bar.

```tsx
<GtkActionBar>
    <x.PackStart><GtkButton label="Cancel" /></x.PackStart>
    <x.PackEnd><GtkButton label="Save" cssClasses={["suggested-action"]} /></x.PackEnd>
</GtkActionBar>
```

---

## Menus

### GtkPopoverMenu with GtkMenuButton

```tsx
<GtkMenuButton iconName="open-menu-symbolic">
    <x.Slot for={GtkMenuButton} id="popover">
        <GtkPopoverMenu>
            <x.MenuSection>
                <x.MenuItem id="new" label="New" onActivate={handleNew} accels="<Control>n" />
                <x.MenuItem id="open" label="Open" onActivate={handleOpen} />
            </x.MenuSection>
            <x.MenuSection>
                <x.MenuSubmenu label="Export">
                    <x.MenuItem id="pdf" label="PDF" onActivate={exportPdf} />
                    <x.MenuItem id="csv" label="CSV" onActivate={exportCsv} />
                </x.MenuSubmenu>
            </x.MenuSection>
            <x.MenuSection>
                <x.MenuItem id="quit" label="Quit" onActivate={quit} accels="<Control>q" />
            </x.MenuSection>
        </GtkPopoverMenu>
    </x.Slot>
</GtkMenuButton>
```

**Menu.Item props:** `id` (required), `label`, `onActivate`, `accels` (e.g., `"<Control>n"`)

---

## Windows

### GtkApplicationWindow

```tsx
<GtkApplicationWindow
    title="App"
    defaultWidth={800}
    defaultHeight={600}
    onClose={quit}
>
    <Content />
</GtkApplicationWindow>
```

Custom titlebar:
```tsx
<GtkApplicationWindow ...>
    <x.Slot for={GtkWindow} id="titlebar">
        <GtkHeaderBar />
    </x.Slot>
    <Content />
</GtkApplicationWindow>
```

---

## Adwaita (Libadwaita)

Import: `import * as Adw from "@gtkx/ffi/adw";`

### AdwApplicationWindow + AdwToolbarView
Modern app structure.

```tsx
<AdwApplicationWindow title="App" defaultWidth={800} defaultHeight={600} onClose={quit}>
    <AdwToolbarView>
        <x.ToolbarTop>
            <AdwHeaderBar>
                <x.Slot for={AdwHeaderBar} id="titleWidget">
                    <AdwWindowTitle title="App" subtitle="Description" />
                </x.Slot>
            </AdwHeaderBar>
        </x.ToolbarTop>
        <MainContent />
        <x.ToolbarBottom>
            <GtkActionBar />
        </x.ToolbarBottom>
    </AdwToolbarView>
</AdwApplicationWindow>
```

### AdwStatusPage
Welcome, error, or empty state.

```tsx
<AdwStatusPage iconName="applications-system-symbolic" title="Welcome" description="Get started" vexpand>
    <GtkButton label="Start" cssClasses={["suggested-action", "pill"]} halign={Gtk.Align.CENTER} />
</AdwStatusPage>
```

### AdwBanner
Dismissable notification.

```tsx
<AdwBanner title="Update available" buttonLabel="Dismiss" revealed={show} onButtonClicked={() => setShow(false)} />
```

### AdwPreferencesPage / AdwPreferencesGroup
Settings UI.

```tsx
<AdwPreferencesPage title="Settings">
    <AdwPreferencesGroup title="Appearance" description="Customize look">
        <AdwSwitchRow title="Dark Mode" active={dark} onActivated={() => setDark(!dark)} />
        <AdwActionRow title="Theme" subtitle="Select color">
            <x.ActionRowPrefix>
                <GtkImage iconName="preferences-color-symbolic" />
            </x.ActionRowPrefix>
            <x.ActionRowSuffix>
                <GtkImage iconName="go-next-symbolic" valign={Gtk.Align.CENTER} />
            </x.ActionRowSuffix>
        </AdwActionRow>
    </AdwPreferencesGroup>
</AdwPreferencesPage>
```

**ActionRow children:** Use `x.ActionRowPrefix` for left widgets, `x.ActionRowSuffix` for right widgets, or `x.Slot for={AdwActionRow} id="activatableWidget"` for clickable suffix.

### AdwExpanderRow
Expandable settings row with optional action widget.

```tsx
<AdwExpanderRow title="Advanced" subtitle="More options">
    <x.ExpanderRowAction>
        <GtkButton iconName="emblem-system-symbolic" cssClasses={["flat"]} />
    </x.ExpanderRowAction>
    <x.ExpanderRowRow>
        <AdwSwitchRow title="Option 1" active />
        <AdwSwitchRow title="Option 2" />
    </x.ExpanderRowRow>
</AdwExpanderRow>
```

**ExpanderRow slots:** `x.ExpanderRowRow` for nested rows, `x.ExpanderRowAction` for header action widget. Direct children also work for simple cases.

### AdwEntryRow / AdwPasswordEntryRow
Input in list row.

```tsx
<AdwEntryRow title="Username" text={username} onChanged={(e) => setUsername(e.getText())} />
<AdwPasswordEntryRow title="Password" />
```

### AdwToggleGroup
Segmented button group for mutually exclusive options.

```tsx
const [viewMode, setViewMode] = useState("list");

<AdwToggleGroup
    activeName={viewMode}
    onNotify={(group, prop) => {
        if (prop === "active-name") {
            setViewMode(group.getActiveName() ?? "list");
        }
    }}
>
    <x.Toggle id="list" iconName="view-list-symbolic" tooltip="List view" />
    <x.Toggle id="grid" iconName="view-grid-symbolic" tooltip="Grid view" />
    <x.Toggle id="flow" label="Flow" />
</AdwToggleGroup>
```

**Toggle props:** `id` (optional), `label`, `iconName`, `tooltip`, `enabled`

### AdwNavigationView
Stack-based navigation with history.

```tsx
const [history, setHistory] = useState(["home"]);

<AdwNavigationView history={history} onHistoryChanged={setHistory}>
    <x.NavigationPage id="home" title="Home">
        <GtkButton label="Go to Details" onClicked={() => setHistory([...history, "details"])} />
    </x.NavigationPage>
    <x.NavigationPage id="details" title="Details" canPop>
        <GtkLabel label="Details content" />
    </x.NavigationPage>
</AdwNavigationView>
```

**NavigationPage props:** `id` (required), `title`, `canPop`. Control navigation via `history` array.

### AdwNavigationSplitView
Sidebar/content split layout for master-detail interfaces.

```tsx
const [selected, setSelected] = useState(items[0]);

<AdwNavigationSplitView sidebarWidthFraction={0.33} minSidebarWidth={200} maxSidebarWidth={300}>
    <x.NavigationPage id="sidebar" title="Sidebar">
        <AdwToolbarView>
            <x.ToolbarTop><AdwHeaderBar /></x.ToolbarTop>
            <GtkListBox cssClasses={["navigation-sidebar"]} onRowSelected={(_, row) => {
                if (!row) return;
                const item = items[row.getIndex()];
                if (item) setSelected(item);
            }}>
                {items.map((item) => <AdwActionRow key={item.id} title={item.title} />)}
            </GtkListBox>
        </AdwToolbarView>
    </x.NavigationPage>

    <x.NavigationPage id="content" title={selected?.title ?? ""}>
        <AdwToolbarView>
            <x.ToolbarTop><AdwHeaderBar /></x.ToolbarTop>
            <GtkLabel label={selected?.title ?? ""} />
        </AdwToolbarView>
    </x.NavigationPage>
</AdwNavigationSplitView>
```

**Props:** `sidebarWidthFraction`, `minSidebarWidth`, `maxSidebarWidth`, `collapsed`, `showContent`.
**NavigationPage slots:** Use `id="sidebar"` for left pane, `id="content"` for right pane.
**Selection:** Use `GtkListBox` with `onRowSelected` (single click) not `onRowActivated` (double click).

### Other Adwaita Widgets

| Widget | Description |
|--------|-------------|
| `AdwClamp` | Limits content width (`maximumSize={600}`) |
| `AdwAvatar` | User avatar (`size={48} text="Name" showInitials`) |
| `AdwSpinner` | Loading indicator |
| `AdwWindowTitle` | Title + subtitle for header bars |
| `AdwButtonRow` | Button styled as list row |

---

## Drag and Drop

All widgets support drag-and-drop through props. Use `onDragPrepare`, `onDragBegin`, and `onDragEnd` to make a widget draggable, and `dropTypes`, `onDrop`, `onDropEnter`, and `onDropLeave` to accept drops.

```tsx
import * as Gdk from "@gtkx/ffi/gdk";
import { Type, Value } from "@gtkx/ffi/gobject";
import { GtkButton, GtkBox, GtkLabel } from "@gtkx/react";
import { useState } from "react";

const DraggableButton = ({ label }: { label: string }) => {
    return (
        <GtkButton
            label={label}
            onDragPrepare={() => Gdk.ContentProvider.newForValue(Value.newFromString(label))}
        />
    );
};

const DropZone = () => {
    const [dropped, setDropped] = useState<string | null>(null);

    return (
        <GtkBox
            dropTypes={[Type.STRING]}
            onDrop={(value: Value) => {
                setDropped(value.getString());
                return true;
            }}
        >
            <GtkLabel label={dropped ?? "Drop here"} />
        </GtkBox>
    );
};
```

## GValue Factories

Create typed values for drag-and-drop and signal emission:

| Factory                        | Description                   |
| ------------------------------ | ----------------------------- |
| `Value.newFromString(str)`     | String values                 |
| `Value.newFromDouble(num)`     | 64-bit floating point         |
| `Value.newFromInt(num)`        | 32-bit signed integer         |
| `Value.newFromBoolean(bool)`   | Boolean values                |
| `Value.newFromObject(obj)`     | GObject instances             |
| `Value.newFromBoxed(boxed)`    | Boxed types (Gdk.RGBA, etc.)  |
| `Value.newFromEnum(gtype, n)`  | Enum values (requires GType)  |
| `Value.newFromFlags(gtype, n)` | Flags values (requires GType) |

Type constants for `dropTypes`: `Type.STRING`, `Type.INT`, `Type.DOUBLE`, `Type.BOOLEAN`, `Type.OBJECT`.

## Custom Drawing

Render custom graphics with `GtkDrawingArea` using the `onDraw` callback:

```tsx
import { GtkDrawingArea } from "@gtkx/react";
import type { Context } from "@gtkx/ffi/cairo";
import * as Gtk from "@gtkx/ffi/gtk";

const Canvas = () => {
    const handleDraw = (self: Gtk.DrawingArea, cr: Context, width: number, height: number) => {
        cr.setSourceRgb(0.2, 0.4, 0.8);
        cr.rectangle(10, 10, width - 20, height - 20);
        cr.fill();
    };

    return <GtkDrawingArea contentWidth={400} contentHeight={300} onDraw={handleDraw} />;
};
```

Use `onGestureDragBegin`, `onGestureDragUpdate`, `onGestureDragEnd` for interactive drawing. Call `widget.queueDraw()` to trigger redraws.

## Adjustment

Configure adjustable widgets declaratively with `x.Adjustment`:

```tsx
import { x, GtkScale, GtkBox, GtkLabel } from "@gtkx/react";
import * as Gtk from "@gtkx/ffi/gtk";
import { useState } from "react";

const VolumeControl = () => {
    const [volume, setVolume] = useState(50);

    return (
        <GtkBox orientation={Gtk.Orientation.VERTICAL} spacing={12}>
            <GtkScale drawValue hexpand>
                <x.Adjustment value={volume} lower={0} upper={100} stepIncrement={1} pageIncrement={10} onValueChanged={setVolume} />
            </GtkScale>
            <GtkLabel label={`Volume: ${Math.round(volume)}%`} />
        </GtkBox>
    );
};
```

Works with `GtkScale`, `GtkScrollbar`, `GtkScaleButton`, `GtkSpinButton`, `GtkListBox`.

**Props:** `value`, `lower`, `upper`, `stepIncrement`, `pageIncrement`, `pageSize`, `onValueChanged`

## TextBuffer

Configure `GtkTextView` buffers declaratively with `x.TextBuffer`. Text content is provided as children, with optional `x.TextTag` elements for formatting.

```tsx
import { x, GtkTextView, GtkScrolledWindow } from "@gtkx/react";

const TextEditor = () => (
    <GtkScrolledWindow minContentHeight={200}>
        <GtkTextView>
            <x.TextBuffer enableUndo onTextChanged={(text) => console.log(text)}>
                Hello, World!
            </x.TextBuffer>
        </GtkTextView>
    </GtkScrolledWindow>
);
```

### Rich Text with TextTag

Apply formatting to portions of text using `x.TextTag`:

```tsx
import { x, GtkTextView, GtkScrolledWindow } from "@gtkx/react";
import * as Pango from "@gtkx/ffi/pango";

const RichTextEditor = () => (
    <GtkScrolledWindow minContentHeight={200}>
        <GtkTextView>
            <x.TextBuffer>
                Normal text, <x.TextTag id="bold" weight={Pango.Weight.BOLD}>bold</x.TextTag>,{" "}
                <x.TextTag id="italic" style={Pango.Style.ITALIC}>italic</x.TextTag>, and{" "}
                <x.TextTag id="red" foreground="red">
                    <x.TextTag id="underline" underline={Pango.Underline.SINGLE}>nested</x.TextTag>
                </x.TextTag> text.
            </x.TextBuffer>
        </GtkTextView>
    </GtkScrolledWindow>
);
```

### Embedded Widgets with TextAnchor

Embed widgets inline with text content:

```tsx
<GtkTextView>
    <x.TextBuffer>
        Click here: <x.TextAnchor>
            <GtkButton label="Click me" />
        </x.TextAnchor> to continue.
    </x.TextBuffer>
</GtkTextView>
```

**TextBuffer props:** `enableUndo`, `onTextChanged`, `onCanUndoChanged`, `onCanRedoChanged`, `children`

**TextTag props:** `id` (required), `priority`, `foreground`, `background`, `weight`, `style`, `underline`, `strikethrough`, `family`, `size`, `sizePoints`, `scale`, `justification`, `leftMargin`, `rightMargin`, `indent`, `editable`, `invisible`

**TextAnchor props:** `children` (widget to embed)

## SourceBuffer

Configure `GtkSourceView` buffers with syntax highlighting using `x.SourceBuffer`:

```tsx
import { x, GtkSourceView, GtkScrolledWindow } from "@gtkx/react";
import { useState } from "react";

const CodeEditor = () => {
    const [code, setCode] = useState('console.log("Hello!");');

    return (
        <GtkScrolledWindow minContentHeight={300}>
            <GtkSourceView showLineNumbers highlightCurrentLine tabWidth={4}>
                <x.SourceBuffer
                    text={code}
                    language="typescript"
                    styleScheme="Adwaita-dark"
                    highlightSyntax
                    highlightMatchingBrackets
                    enableUndo
                    onTextChanged={setCode}
                />
            </GtkSourceView>
        </GtkScrolledWindow>
    );
};
```

**Props:** `text`, `language`, `styleScheme`, `highlightSyntax`, `highlightMatchingBrackets`, `enableUndo`, `onTextChanged`, `onCanUndoChanged`, `onCanRedoChanged`, `onCursorMoved`

## Keyboard Shortcuts

Attach shortcuts with `x.ShortcutController` and `x.Shortcut`:

```tsx
import { x, GtkBox, GtkLabel } from "@gtkx/react";
import * as Gtk from "@gtkx/ffi/gtk";
import { useState } from "react";

const App = () => {
    const [count, setCount] = useState(0);

    return (
        <GtkBox orientation={Gtk.Orientation.VERTICAL} spacing={12} focusable>
            <x.ShortcutController scope={Gtk.ShortcutScope.LOCAL}>
                <x.Shortcut trigger="<Control>equal" onActivate={() => setCount((c) => c + 1)} />
                <x.Shortcut trigger="<Control>minus" onActivate={() => setCount((c) => c - 1)} />
            </x.ShortcutController>
            <GtkLabel label={`Count: ${count}`} />
        </GtkBox>
    );
};
```

**Scopes:** `LOCAL` (widget focus), `MANAGED` (parent managed), `GLOBAL` (window-wide)

**Trigger syntax:** `<Control>s`, `<Control><Shift>s`, `<Alt>F4`, `<Primary>q`, `F5`

**Multiple triggers:** `trigger={["F5", "<Control>r"]}`
